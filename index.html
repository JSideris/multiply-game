<!DOCTYPE html>
<html>
<head>
    <title>Multiply Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }

        canvas {
            flex: 1;
            width: 100%;
            background-color: #222;
        }

        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: #000;
        }

        #answerInput {
            margin: 0 10px;
            padding: 5px;
            font-size: 18px;
            width: 200px;
            text-align: center;
        }

        button {
            background-color: transparent;
            color: #ffffff;
            border: 2px solid #ffffff;
            padding: 8px 16px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
        }

        #mute-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 40px;
        }

        @media (max-width: 600px) {
            #answerInput {
                width: 80%;
                font-size: 24px;
            }
            #skip-btn {
                font-size: 18px;
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">
        <input type="number" id="answerInput" placeholder="Type your answer">
        <button id="skip-btn">Skip</button>
    </div>
    <button id="mute-btn">ðŸ”Š</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const answerInput = document.getElementById('answerInput');
        const muteBtn = document.getElementById('mute-btn');
        const skipBtn = document.getElementById('skip-btn');

		// Give the input focus immediately, and when the user clicks anywhere on the canvas.
		canvas.addEventListener('click', function() {
			answerInput.focus();
		});
		answerInput.focus();

        let audioEnabled = true;

        muteBtn.addEventListener('click', function() {
            audioEnabled = !audioEnabled;
            this.innerText = audioEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
        });

        skipBtn.addEventListener('click', skipProblem);

        // Initialize AudioContext for sound
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Generic function to play a beep
        function playBeep(frequency, duration) {
            if (!audioEnabled) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // Sound for correct answer
        function playCorrectSound() {
            playBeep(1000, 0.1);
        }

        // Sound for incorrect answer
        function playIncorrectSound() {
            playBeep(500, 0.2);
        }

        // Sound for game over
        function playGameOverSound() {
            if (!audioEnabled) return;
            const now = audioCtx.currentTime;
            const freqs = [800, 600, 400];
            freqs.forEach((freq, index) => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freq, now + index * 0.2);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start(now + index * 0.2);
                oscillator.stop(now + index * 0.2 + 0.1);
            });
        }

        // Game variables
        let problems = [];
        let score = 0;
        let skips = 3;
        let gameOver = false;
        let laserActive = false;
        let laserTarget = null;
        let explosions = [];
        let misfireFrames = 0;
        let spawnCounter = 0;
        let spawnInterval = 300;
        const maxProblems = 5;
        const baseSpeed = 0.3;
        let level1 = 0.5;
        let level2 = 0.5;
        const levelIncrement = 0.01;
        let gameOverSoundPlayed = false;

        function generateProblem(score) {
            level1 += levelIncrement * 1.2;
            level2 += levelIncrement;
            const maxLevel = 100;
            level1 = Math.min(level1, maxLevel);
            level2 = Math.min(level2, maxLevel);
            const maxNum1 = Math.floor(10 + level1 * 10);
            const maxNum2 = Math.floor(10 + level2 * 10);
            let num1 = Math.floor(Math.random() * maxNum1) + 1;
            let num2 = Math.floor(Math.random() * maxNum2) + 1;
            let expression = `${num1}x${num2}`;
            let product = num1 * num2;
            let width = 100 + Math.floor(level1 + level2) * 10;
            let height = 30;
            if (Math.random() < 0.1 && level1 > 10 && level2 > 10) {
                let num3 = Math.floor(Math.random() * 10) + 1;
                expression = `${num1}x${num2}x${num3}`;
                product = num1 * num2 * num3;
                width += 50;
            }
            width = Math.min(width, canvas.width / 2);
            return { expression, product, width, height };
        }

        function update() {
            if (gameOver) return;
            problems.forEach(p => {
                p.y += baseSpeed;
                if (p.y >= canvas.height) {
                    gameOver = true;
                }
            });
            spawnCounter++;
            if (spawnCounter >= spawnInterval && problems.length < maxProblems) {
                spawnCounter = 0;
                let newProblem = generateProblem(score);
                newProblem.x = Math.random() * (canvas.width - newProblem.width);
                newProblem.y = 0;
                newProblem.speed = baseSpeed;
                problems.push(newProblem);
            }
            explosions = explosions.filter(exp => exp.age <= 30);
            explosions.forEach(exp => exp.age++);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            problems.forEach(p => {
                ctx.fillStyle = '#444';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.fillStyle = '#fff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.expression, p.x + p.width / 2, p.y + p.height / 2);
            });
            ctx.fillStyle = '#f00';
            const cannonX = canvas.width / 2;
            const cannonY = canvas.height - 20;
            ctx.beginPath();
            ctx.moveTo(cannonX - 10, cannonY);
            ctx.lineTo(cannonX + 10, cannonY);
            ctx.lineTo(cannonX, cannonY - 20);
            ctx.closePath();
            ctx.fill();
            if (laserActive) {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(cannonX, cannonY - 20);
                ctx.lineTo(laserTarget.x, laserTarget.y);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            explosions.forEach(exp => {
                let radius = exp.age * 2;
                let alpha = 1 - exp.age / 30;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.fill();
            });
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.fillText(`Skips: ${skips}`, 10, 60);
            if (misfireFrames > 0) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                misfireFrames--;
            }
            if (gameOver) {
                if (!gameOverSoundPlayed) {
                    playGameOverSound();
                    gameOverSoundPlayed = true;
                }
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 50);
                ctx.font = '30px Arial';
                ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2);
                ctx.fillText('Click to Try Again', canvas.width / 2, canvas.height / 2 + 50);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function shootLaser(problem) {
            laserActive = true;
            laserTarget = { x: problem.x + problem.width / 2, y: problem.y + problem.height / 2 };
            setTimeout(() => {
                laserActive = false;
                createExplosion(laserTarget.x, laserTarget.y);
                problems = problems.filter(p => p !== problem);
                score += problem.product;
            }, 100);
        }

        function createExplosion(x, y) {
            explosions.push({ x, y, age: 0 });
        }

        function misfireAnimation() {
            misfireFrames = 5;
        }

        function skipProblem() {
            if (skips > 0 && problems.length > 0) {
                let lowestProblem = problems.reduce((a, b) => a.y > b.y ? a : b);
                problems = problems.filter(p => p !== lowestProblem);
                skips--;
            }
        }

        // Handle answer input with sounds
        answerInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                let answer = parseInt(this.value);
                let problem = problems.find(p => p.product === answer);
                if (problem) {
                    playCorrectSound();
                    shootLaser(problem);
                } else {
                    playIncorrectSound();
                    misfireAnimation();
                }
                this.value = '';
            }
        });

        // Handle skips with spacebar
        answerInput.addEventListener('keydown', function(e) {
            if (e.key === ' ') {
                e.preventDefault();
                skipProblem();
            }
        });

        // Handle game restart
        canvas.addEventListener('click', function() {
            if (gameOver) {
                problems = [];
                score = 0;
                skips = 3;
                gameOver = false;
                level1 = 0.5;
                level2 = 0.5;
                gameOverSoundPlayed = false;
                answerInput.focus();
            }
        });

        // Resize canvas function
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }

        // Initial resize
        resizeCanvas();

        // Resize on window resize
        window.addEventListener('resize', resizeCanvas);

        // Initialize
        answerInput.focus();
        gameLoop();
    </script>
</body>
</html>